<!doctype html>

<html>

<body>
   <canvas width="768" height="768" id="gl-canvas">
      Sorry; your web browser does not support HTML5â€™s canvas element.
   </canvas>

   <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"
      type="text/javascript"></script>
   <script src="shapes.js"></script>
   <script src="gl-utilities.js"></script>
   <script src="Part3/object-shader.js"></script>
   <script src="Part3/skybox-shader.js"></script>
   <!--Use part 2 object management as base with skybox-management.js as extra-->
   <script src="Part2/object-management.js"></script>
   <script src="Part3/skybox-management.js"></script>

   <script>
      // Create a canvas to paint on
      var canvas = document.getElementById('gl-canvas');
      var gl = canvas.getContext('webgl');

      glInit();
      shaderprogram = createProgram(vertCode, fragCode);

      // Create the objects to render.
      let benchObject = bench();
      let object2 = flower();
      let object3 = cube();

      // Initialise the object's buffers and edit the model matrix of each to place them in the world.
      let buffersBench = initObject(benchObject, shaderprogram);
      let buffers2 = initObject(object2, shaderprogram);
      mat4.fromRotationTranslationScale(buffers2.model, quat.create(), [1, 0, 0], [0.3, 0.3, 0.3]);
      let buffers3 = initObject(object3, shaderprogram);
      mat4.fromRotationTranslationScale(buffers3.model, quat.create(), [-1, 0, 0], [0.3, 0.3, 0.3]);
      let buffers = [buffersBench, buffers2, buffers3];
      let directions = [[-0.005, 0.05, 0.0], [0.05, 0, 0], [0, 0.05, 0]];

      // Load the skybox texture into the object shader program to let them reflect it using environment mapping.
      loadSkyboxTexture(shaderprogram);

      // This function will allow recursion by combining object's model with parent's
      returnM = function (object, time) {
         if (object.parent == null)
            return object.createM(time);
         else
            return mat4.multiply(object.M_combined, returnM(object.parent, time), object.createM(time));
      }

      buffersBench.M_combined = mat4.create();
      buffersBench.createM = function (time) {
         let model = buffersBench.model;
         mat4.fromScaling(model, [1, 1, 1]);
         mat4.rotateY(model, model, 0.03 * time);
         mat4.translate(model, model, [0.25, -0.5, -0.5]);
         return model;
      }
      buffersBench.parent = null;

      buffers2.M_combined = mat4.create();
      buffers2.createM = function (time) {
         let model = buffers2.model;
         mat4.fromScaling(model, [0.25, 0.25, 0.25]);
         mat4.rotateY(model, model, 0.03 * time);
         //mat4.rotateX(model, model, 0.03 * time);
         mat4.translate(model, model, [4, 0, 0]);
         return model;
      }
      buffers2.parent = buffersBench;

      buffers3.M_combined = mat4.create();
      buffers3.createM = function (time) {
         let model = buffers3.model;
         mat4.fromScaling(model, [0.25, 0.25, 0.25]);
         mat4.rotateY(model, model, 0.03 * time);
         //mat4.rotateZ(model, model, 0.03 * time);
         mat4.translate(model, model, [-4, 0, 0]);
         return model;
      }
      buffers3.parent = buffersBench;

      // Create a view matrix. glMatrix helps us here with lookAt function
      let M_view = mat4.create();
      mat4.lookAt(M_view, [0, 0.5, 1.5], [0, 0, 0], [0, 1, 0]);

      // Create a perspective matrix. glMatrix helps us here with perspective function
      let P = mat4.create();
      mat4.perspective(P, Math.PI / 2, canvas.width / canvas.height, .01, 10);

      // Tell WebGL to use M_view as the GLSL uniform uViewMatrix
      let ViewLoc = gl.getUniformLocation(shaderprogram, "uViewMatrix");
      gl.uniformMatrix4fv(ViewLoc, false, new Float32Array(M_view));

      // Tell WebGL to use P as the GLSL uniform uPerspectiveMatrix
      let PerspLoc = gl.getUniformLocation(shaderprogram, "uPerspectiveMatrix");
      gl.uniformMatrix4fv(PerspLoc, false, new Float32Array(P));

      // Initialise the skybox.
      skyboxshaderprogram = createProgram(vertCodeSkybox, fragCodeSkybox);
      let skyboxObject = cuboid(-1, 1, -1, 1, -1, 1);
      let skyboxBuffers = initSkybox(skyboxObject, skyboxshaderprogram);

      let viewDirectionMatrix = mat4.create();
      mat4.copy(viewDirectionMatrix, M_view);
      viewDirectionMatrix[12] = 0;
      viewDirectionMatrix[13] = 0;
      viewDirectionMatrix[14] = 0;

      let viewDirectionProjectionMatrix = mat4.create();
      mat4.multiply(viewDirectionProjectionMatrix, P, viewDirectionMatrix);
      let viewDirectionProjectionInverseMatrix = mat4.create();
      mat4.invert(viewDirectionProjectionInverseMatrix, viewDirectionProjectionMatrix);


      // Initialise working matrices.
      // This lets the objects be rotated over time with the additional directions vectors.
      let M = mat4.create();
      let R = mat4.create();
      let Norm = mat4.create();
      let MV = mat4.create();

      let then = 0;
      function render(now) {
         let delta = 0.001 * (now - then);
         then = now;
         now /= 100;

         glInit();
         gl.useProgram(shaderprogram);
         for (let i = 0; i < buffers.length; i++) {
            // Set up the Model matrix for GLSL.
            M = returnM(buffers[i], now);

            let ModelLoc = gl.getUniformLocation(shaderprogram, "uModelMatrix");
            gl.uniformMatrix4fv(ModelLoc, false, new Float32Array(M));

            // calc normal matrix
            mat4.multiply(MV, M_view, M);
            mat4.transpose(Norm, MV);
            mat4.invert(Norm, Norm);
            let NormLoc = gl.getUniformLocation(shaderprogram, "uNormalMatrix");
            gl.uniformMatrix4fv(NormLoc, false, new Float32Array(Norm));

            // Invert the view matrix to get the transformation from view space to world space
            let M_camera = mat4.create();
            mat4.invert(M_camera, M_view);

            // Transform the camera position from view space to world space
            let cameraPositionWorldSpace = vec3.create();
            vec3.transformMat4(cameraPositionWorldSpace, [0, 0, 0], M_camera);

            // Set the value of uModelCameraPosition uniform in the shader program
            let ModelCameraLoc = gl.getUniformLocation(shaderprogram, "uModelCameraPosition");
            gl.uniform3f(ModelCameraLoc, cameraPositionWorldSpace[0], cameraPositionWorldSpace[1], cameraPositionWorldSpace[2]);

            drawObject(buffers[i], shaderprogram);
         }

         // draw the skybox
         gl.depthFunc(gl.LEQUAL); // let our quad pass the depth test at 1.0
         gl.useProgram(skyboxshaderprogram);
         let ViewDirectionProjectionInverseMatrixLoc = gl.getUniformLocation(skyboxshaderprogram, "uViewDirectionProjectionInverse");
         gl.uniformMatrix4fv(ViewDirectionProjectionInverseMatrixLoc, false, new Float32Array(viewDirectionProjectionInverseMatrix));
         drawSkybox(skyboxBuffers, skyboxshaderprogram);

         // request to re-run this function next time a redraw is needed
         requestAnimationFrame(render);
      }
      requestAnimationFrame(render);

   </script>
</body>

</html>