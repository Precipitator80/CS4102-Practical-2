<!doctype html>

<html>

<body>
   <canvas width="768" height="768" id="gl-canvas">
      Sorry; your web browser does not support HTML5â€™s canvas element.
   </canvas>

   <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"
      type="text/javascript"></script>
   <script src="shapes.js"></script>
   <script src="gl-utilities.js"></script>
   <script src="Part3/object-shader.js"></script>
   <script src="Part3/skybox-shader.js"></script>
   <!--Use part 2 object management as base with init-environment-map.js as extra-->
   <script src="Part2/object-management.js"></script>
   <script src="Part3/init-environment-map.js"></script>

   <script>
      // Create a canvas to paint on
      var canvas = document.getElementById('gl-canvas');
      var gl = canvas.getContext('webgl');

      glInit();
      shaderprogram = createProgram(vertCode, fragCode);

      // Create the objects to render.
      let object1 = bench();
      let object2 = cube();
      let object3 = cube();

      // Initialise the object's buffers and edit the model matrix of each to place them in the world.
      let buffers1 = initObject(object1, shaderprogram);
      let buffers2 = initObject(object2, shaderprogram);
      mat4.fromRotationTranslationScale(buffers2.model, quat.create(), [1, 0, 0], [0.3, 0.3, 0.3]);
      let buffers3 = initObject(object3, shaderprogram);
      mat4.fromRotationTranslationScale(buffers3.model, quat.create(), [-1, 0, 0], [0.3, 0.3, 0.3]);
      let buffers = [buffers1, buffers2, buffers3];
      let directions = [[-0.005, 0.05, 0.0], [0.05, 0, 0], [0, 0.05, 0]];

      // Initialite the environment map to reflect the skybox.
      initEnvironmentMap(shaderprogram);

      // Create a view matrix. glMatrix helps us here with lookAt function
      let M_view = mat4.create();
      mat4.lookAt(M_view, [0, 0.5, 1.5], [0, 0, 0], [0, 1, 0]);

      // Create a perspective matrix. glMatrix helps us here with perspective function
      let P = mat4.create();
      mat4.perspective(P, Math.PI / 2, canvas.width / canvas.height, .01, 10);

      // Tell WebGL to use M_view as the GLSL uniform uViewMatrix
      let ViewLoc = gl.getUniformLocation(shaderprogram, "uViewMatrix");
      gl.uniformMatrix4fv(ViewLoc, false, new Float32Array(M_view));

      // Tell WebGL to use P as the GLSL uniform uPerspectiveMatrix
      let PerspLoc = gl.getUniformLocation(shaderprogram, "uPerspectiveMatrix");
      gl.uniformMatrix4fv(PerspLoc, false, new Float32Array(P));

      // Initialise working matrices.
      // This lets the objects be rotated over time with the additional directions vectors.
      let M = mat4.create();
      let R = mat4.create();
      let Norm = mat4.create();
      let MV = mat4.create();

      let then = 0;
      function render(now) {
         let delta = 0.001 * (now - then);
         then = now;
         now /= 100;

         glInit();
         for (let i = 0; i < buffers.length; i++) {
            // Set up the Model matrix for GLSL. We will combine rotation with positioning here
            mat4.identity(R);
            mat4.rotateX(R, R, directions[i][0] * now);
            mat4.rotateY(R, R, directions[i][1] * now);
            mat4.rotateZ(R, R, directions[i][2] * now);
            mat4.multiply(M, buffers[i].model, R);
            let ModelLoc = gl.getUniformLocation(shaderprogram, "uModelMatrix");
            gl.uniformMatrix4fv(ModelLoc, false, new Float32Array(M));

            // calc normal matrix
            mat4.multiply(MV, M_view, M);
            mat4.transpose(Norm, MV);
            mat4.invert(Norm, Norm);
            let NormLoc = gl.getUniformLocation(shaderprogram, "uNormalMatrix");
            gl.uniformMatrix4fv(NormLoc, false, new Float32Array(Norm));

            // Invert the view matrix to get the transformation from view space to world space
            let M_camera = mat4.create();
            mat4.invert(M_camera, M_view);

            // Transform the camera position from view space to world space
            let cameraPositionWorldSpace = vec3.create();
            vec3.transformMat4(cameraPositionWorldSpace, [0, 0, 0], M_camera);

            // Set the value of uModelCameraPosition uniform in the shader program
            let ModelCameraLoc = gl.getUniformLocation(shaderprogram, "uModelCameraPosition");
            gl.uniform3f(ModelCameraLoc, cameraPositionWorldSpace[0], cameraPositionWorldSpace[1], cameraPositionWorldSpace[2]);

            drawObject(buffers[i], shaderprogram);
         }

         // request to re-run this function next time a redraw is needed
         requestAnimationFrame(render);
      }
      requestAnimationFrame(render);

   </script>
</body>

</html>